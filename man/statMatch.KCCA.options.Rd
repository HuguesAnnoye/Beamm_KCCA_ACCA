% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/statMatch.KCCA.options.R
\name{statMatch.KCCA.options}
\alias{statMatch.KCCA.options}
\title{Statistical Matching: KCCA options}
\usage{
statMatch.KCCA.options(
  print.details = TRUE,
  print.details_tuning = FALSE,
  scaling = c("z-score", "min-max", "no"),
  tuning_type = c("two h", "one h", "random"),
  type_predict = c("loop", "matrix"),
  exactMatch = FALSE,
  names.CV_Cat_prio = NULL,
  n_fold = 5L,
  par = FALSE,
  par_fold = TRUE,
  nc = 2L,
  d = NULL,
  p1_dmax = 2L,
  p1_dmin = 2L,
  p1_dstep = 2L,
  p2_dmax = 2L,
  p2_dmin = 2L,
  p2_dstep = 2L,
  rot = FALSE,
  p1_kernel_predict = c("alea", "epan", "gauss"),
  p1_kernel_predict_tuning = NULL,
  p2_kernel_predict = c("gauss", "epan", "alea"),
  p1_objmethod = c("wRMSE", "wsRMSE", "wMCR", "wCE"),
  p2_objmethod = c("wsRMSE", "wRMSE", "wCE"),
  p1_h = NULL,
  p1_hmax = 1,
  p1_hmin = 0.01,
  p1_hstep = 0.1,
  p1_hx = NULL,
  p1_hxmax = 1,
  p1_hxmin = 0.01,
  p1_hxstep = 0.25,
  p1_hy = NULL,
  p1_hymax = NULL,
  p1_hymin = NULL,
  p1_hystep = NULL,
  p1_g = 2e-05,
  p1_gmax = 1e-04,
  p1_gmin = 1e-05,
  p1_gstep = 1e-05,
  p2_h = NULL,
  p2_hmax = 1,
  p2_hmin = 0.01,
  p2_hstep = 0.1,
  p2_hx = NULL,
  p2_hxmax = 1,
  p2_hxmin = 0.01,
  p2_hxstep = 0.25,
  p2_hy = NULL,
  p2_hymax = NULL,
  p2_hymin = NULL,
  p2_hystep = NULL,
  p2_g = 2e-05,
  p2_gmax = 1e-04,
  p2_gmin = 1e-05,
  p2_gstep = 1e-05,
  p1_n_combs = 10L,
  p2_n_combs = 10L,
  p1_man_params = NULL,
  p2_man_params = NULL
)
}
\arguments{
\item{print.details}{Logical Value, print details or not (in the tuning part only print the value of the objective function for each parameters combination).}

\item{print.details_tuning}{Logical Value, if true print all the details in the tuning part.}

\item{scaling}{a character string, the name of the method used to scale the variables in the receiver and donor data sets: \code{"z-score"}, \code{"min-max"} or \code{"no"} (no scaling).}

\item{tuning_type}{a character string, the method used to find the optimal tuning parameters: \code{"random"}, \code{"two h"} or \code{"one h"}}

\item{type_predict}{a character string, Type of prediction \code{"matrix"} or \code{"loop"}.}

\item{exactMatch}{a logical, indicate if an exact matching has to be performed or not.}

\item{names.CV_Cat_prio}{a character vector, Name of common categorical variable that have to match.}

\item{n_fold}{a positive integer, number of folds used for the cross-validation of the tuning parameters.}

\item{par}{a logical, if TRUE doing parallelisation during the tuning phase}

\item{nc}{a positive integer, number of core to use during the tuning phase}

\item{d}{a positive integer, number of latent variable used in CCA.}

\item{p1_dmax}{a positive integer, number of latent variable used in CCA.}

\item{p1_dmin}{a positive integer, number of latent variable used in CCA.}

\item{p1_dstep}{a positive integer, number of latent variable used in CCA.}

\item{p2_dmax}{a positive integer, number of latent variable used in CCA.}

\item{p2_dmin}{a positive integer, number of latent variable used in CCA.}

\item{p2_dstep}{a positive integer, number of latent variable used in CCA.}

\item{rot}{a logical, if TRUE the bandwidth is h multiply by the variance.}

\item{p1_kernel_predict}{a character string, Type of kernel use for prediction for categorical variable.}

\item{p1_kernel_predict_tuning}{a character string, Type of kernel use for the tuning for categorical variable by default the same than kernel_predict.}

\item{p2_kernel_predict}{a character string, Type of kernel use for prediction for continuous variable.}

\item{p1_objmethod}{a character string, Method using for the tuning.}

\item{p2_objmethod}{a character string, Method using for the tuning.}

\item{p1_h}{a numeric vector, vector of value for h, the bandwidth of the Matching kernel for categorical variable.}

\item{p1_hmax}{a numeric value, maximal value for h, the bandwidth of the Matching kernel for categorical variable.}

\item{p1_hmin}{a numeric value, minimal value for h, the bandwidth of the Matching kernel for categorical variable.}

\item{p1_hstep}{a numeric value, step for the grid of h for categorical variable.}

\item{p1_hx}{a numeric vector, vector of value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p1_hxmax}{a numeric value, maximal value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p1_hxmin}{a numeric value, minimal value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p1_hxstep}{a numeric value,  step for the grid of h for categorical variable.}

\item{p1_hy}{a numeric vector, vector of value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p1_hymax}{a numeric value, maximal value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p1_hymin}{a numeric value, minimal value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p1_hystep}{a numeric value, step for the grid of h for categorical variable.}

\item{p1_g}{a numeric vector, vector of value for g, the regularization parameter for categorical variable.}

\item{p1_gmax}{a numeric value, maximal value for g, the regularization parameter for categorical variable.}

\item{p1_gmin}{a numeric value, minimal value for g, the regularization parameter for categorical variable.}

\item{p1_gstep}{a numeric value, mtep for the grid of g for categorical variable.}

\item{p2_h}{a numeric vector, vector of value for h, the bandwidth of the Matching kernel for continuous variable.}

\item{p2_hmax}{a numeric value, maximal value for h, the bandwidth of the Matching kernel for continuous variable.}

\item{p2_hmin}{a numeric value, minimal value for h, the bandwidth of the Matching kernel for continuous variable.}

\item{p2_hstep}{a numeric value, step for the grid of h for continuous variable.}

\item{p2_hx}{a numeric vector, vector of value for h, the bandwidth of the KCCA kernel for categorical variable.}

\item{p2_hxmax}{a numeric value, maximal value for h, the bandwidth of the KCCA kernel for continuous variable.}

\item{p2_hxmin}{a numeric value, minimal value for h, the bandwidth of the KCCA kernel for continuous variable.}

\item{p2_hxstep}{a numeric value, step for the grid of h for continuous variable.}

\item{p2_hy}{a numeric vector, vector of value for h, the bandwidth of the KCCA kernel for continuous variable.}

\item{p2_hymax}{a numeric value, maximal value for h, the bandwidth of the KCCA kernel for continuous variable.}

\item{p2_hymin}{a numeric value, minimal value for h, the bandwidth of the KCCA kernel for continuous variable.}

\item{p2_hystep}{a numeric value, step for the grid of h for continuous variable.}

\item{p2_g}{a numeric vector, vector of value for g, the regularization parameter for continuous variable.}

\item{p2_gmax}{a numeric value, maximal value for g, the regularization parameter for continuous variable.}

\item{p2_gmin}{a numeric value, minimal value for g, the regularization parameter for continuous variable.}

\item{p2_gstep}{a numeric value, step for the grid of g for continuous variable.}

\item{p1_n_combs}{a positive integer, number of random combinations of tuning parameters generated in phase 1 (used only when \code{tuning_type = "random"}).}

\item{p2_n_combs}{a positive integer, number of random combinations of tuning parameters generated in phase 2 (used only when \code{tuning_type = "random"}).}

\item{p1_man_params}{a data.frame, a manual way to specify the grid of tuning parameters in phase 1.}

\item{p2_man_params}{a data.frame, a manual way to specify the grid of tuning parameters in phase 2.}
}
\value{
A list with all the options required by the statistical matching algorithm based on KCCA.
}
\description{
Function to create the options for KCCA.
}
\details{
DETAILS
}
